/*
 Group - 5
 Vikram Waradpande - 2015B4A70454P
 Rinkesh Jain - 2015B4A70590P
 Yajat Dawar - 2015B4A70620P
 Anmol Naugaria - 2015B4A70835P
*/


#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include <time.h>


#ifndef TERMANDNONTERM
#define TERMANDNONTERM
//Map from an enum of type nonterminal to its string
char* nTerminalString[] = {"program","mainFunction","otherFunctions","function","input_par","output_par","parameter_list","dataType","primitiveDatatype",
"constructedDatatype","remaining_list","stmts","typeDefinitions","typeDefinition","fieldDefinitions","fieldDefinition","moreFields",
"declarations","declaration","global_or_not","otherStmts","stmt","assignmentStmt","singleOrRecId","new_24","funCallStmt","outputParameters",
"inputParameters","iterativeStmt","conditionalStmt","elsePart","ioStmt","allVar","arithmeticExpression","expPrime","term","termPrime",
"factor","highPrecedenceOperators","lowPrecedenceOperators","all","temp","booleanExpression","var","logicalOp","relationalOp","returnStmt",
"optionalReturn","idList","more_ids","allVarDash"};


//Map from an enum of type terminal to its string
char* TString[] = {"TK_ASSIGNOP","TK_COMMENT","TK_FIELDID","TK_ID","TK_NUM","TK_RNUM","TK_FUNID","TK_RECORDID","TK_WITH",
"TK_PARAMETERS","TK_END","TK_WHILE","TK_TYPE","TK_MAIN","TK_GLOBAL","TK_PARAMETER","TK_LIST","TK_SQL","TK_SQR","TK_INPUT",
"TK_OUTPUT","TK_INT","TK_REAL","TK_COMMA","TK_SEM","TK_COLON","TK_DOT","TK_ENDWHILE","TK_OP","TK_CL","TK_IF","TK_THEN",
"TK_ENDIF","TK_READ","TK_WRITE","TK_RETURN","TK_PLUS","TK_MINUS","TK_MUL","TK_DIV","TK_CALL","TK_RECORD","TK_ENDRECORD",
"TK_ELSE","TK_AND","TK_OR","TK_NOT","TK_LT","TK_LE","TK_EQ","TK_GT","TK_GE","TK_NE","eps","$","TK_ERROR"};
#endif


#include "lexer.h"
#include "parser.h"
#include "symbolTable.h"
#include "typeChecker.h"
#include "semanticAnalyzer.h"
#include "codeGen.h"


int option = -1;

//Remove comments from source code
void removeComments(FILE* fp)
{
 char newLine[MAX];
 while(fgets(newLine,MAX+1,fp)!=NULL)
 {
	 int currInd = 0;
	 while(currInd < MAX && (newLine[currInd]==' ' || newLine[currInd]=='\t'))
		 currInd++;
	 if(currInd<MAX)
		 if(newLine[currInd]=='%')
			 continue;
	 printf("%s",newLine);
 }
}



int main(int argc, char* argv[])
{

 printf("LEVEL 4: AST / Symbol Table / Type Checker / Semantic Analyzer modules work properly.\n\n");
 printf("1) Options 0-9 are completely implemented and are error free.\n");
 printf("2) ASM code for arithmetic and assignment statements is generated in a file code.asm file.\n");
 printf("3) All semantic errors mentiond in the language specifications are implemnted\n");
 printf("4) We assume that the returned variable from a function should match its name with the name in the output parameter list, else we report it as a semantic error.\n\n\n");


 FILE* grammarFile;

 //The testcase for the file
 FILE* sourceFile;

 int option = -1;

 printf("Enter your option\n\n");
 printf("0: Exit\n");
 printf("1: Print the token list generated by Lexer\n");
 printf("2: Print Parser Tree and point out Lexical or Synatactic Errors if Any\n");
 printf("3: Print the Abstract Syntax Tree\n");
 printf("4: Print Allocated Memory and Nodes of Parse Tree and AST\n");
 printf("5: Print the Symbol Table\n");
 printf("6: Print Global Variables\n");
 printf("7: Print total Memory for each function\n");
 printf("8: Print Information of Records\n");
 printf("9: Compile and verify syntactic and semantic errors in the source code.\n");
 printf("10: Generate code.asm corresponding to the source file. (NOT implemnted completely)\n");

 printf("Enter your option.\n");
 scanf("%d",&option);

 while(1)
 {
	 if(option==0)
	 {
		 printf("Exiting the program\n");
		 break;
	 }


	 else if(option == 1)
	 {
		 sourceFile = fopen(argv[1],"r");
		 initializeLexer();
		 printf("Printing tokens line by line:\n");

		 TokenInfo newToken = getNextToken(sourceFile);

		 while(overFlag==0 && newToken!=NULL)
		 {
			 printf("%d  %s : %s\n",newToken->lineNumber,TString[newToken->token],newToken->lexeme);
			 newToken = getNextToken(sourceFile);
		 }

		 if(newToken!=NULL)
			 printf("%d  %s : %s\n",newToken->lineNumber,TString[newToken->token],newToken->lexeme);

		 fclose(sourceFile);

	 }

	 else if(option == 2){


       sourceFile = fopen(argv[1],"r");
       grammarFile = fopen("grammar.txt","r");
			 initializeLexer();
			 initializeParser(grammarFile);
       buildTreeAndParse(sourceFile);

       if(syntacticCorrectnessFlag == 0)
       {
         printf("Program is syntactically incorrect. Printing parse tree:\n");
       }
			 else{
         printf("Parsing successful: Program is syntactically correct.");
       }


			 printf("Pretty printing parse tree on the console\n");
			 prettyPrintParseTree(root,0);
       printf("\n\n Errors (if any) already printed above the parse tree");
			 fclose(sourceFile);
			 fclose(grammarFile);

	 }

	 else if(option == 3){

     sourceFile = fopen(argv[1],"r");
     grammarFile = fopen("grammar.txt","r");
     initializeLexer();
     initializeParser(grammarFile);
     buildTreeAndParse(sourceFile);

     if(syntacticCorrectnessFlag == 0)
     {
       printf("Program is syntactically incorrect. Can't create AST for the source code\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }
     else{
       createAST(root);
       printf("AST Traversal Order: Children from left to right before parent\n\n");
       printf("Pretty printing AST tree on the console\n");
       prettyPrintParseTree(root,0);
       printf("\n\n Traversal order printed above the AST\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }

	 }


	 else if(option==4)
	 {
		 sourceFile = fopen(argv[1],"r");
		 grammarFile = fopen("grammar.txt","r");

		 initializeLexer();
		 initializeParser(grammarFile);
		 buildTreeAndParse(sourceFile);

     if(syntacticCorrectnessFlag == 0)
     {
       printf("Program is syntactically incorrect.\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }
     else{
        printErrorFlag = 0;
        createAST(root);
        printf("\nParse Tree Number of Nodes = %d \t\t",n1);
        int parseTreeMemory = (int)sizeof(struct treeNode)*n1;
        printf("Allocated Memory = %d\n\n",parseTreeMemory);
        printf("AST Number of Nodes = %d \t\t",n1-n2);
        int astMemory = sizeof(struct treeNode)*(n1-n2);
        printf("Allocated Memory = %d\n\n",astMemory);
        double percentage = (double)(parseTreeMemory-astMemory)/parseTreeMemory*100;
        printf("Compression Percentage = %.2f percent\n",percentage);
        fclose(sourceFile);
        fclose(grammarFile);
     }

	 }

	 else if(option==5)
	 {
		 sourceFile = fopen(argv[1],"r");
		 grammarFile = fopen("grammar.txt","r");
		 initializeLexer();
		 initializeParser(grammarFile);
		 buildTreeAndParse(sourceFile);

     if(syntacticCorrectnessFlag == 0)
     {
       printf("Program is syntactically incorrect.\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }
     else{
        createAST(root);
        initializeSymbolTableVariables();
        printErrorFlag = 0;
        populateSymbolTable(root);
        printf("\n\n");
        calculateOffset();
        printSymbolTable();
        fclose(sourceFile);
        fclose(grammarFile);
     }
	 }

	 else if(option==6)
	 {
		 sourceFile = fopen(argv[1],"r");
		 grammarFile = fopen("grammar.txt","r");

		 initializeLexer();
		 initializeParser(grammarFile);
		 buildTreeAndParse(sourceFile);

     if(syntacticCorrectnessFlag == 0)
     {
       printf("Program is syntactically incorrect.\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }
     else{
       printErrorFlag = 0;
       createAST(root);
       initializeSymbolTableVariables();
       populateSymbolTable(root);
       printf("\n\n");
       calculateOffset();
       printGlobalTable();
     }

	 }

	 else if(option==7)
	 {
		 sourceFile = fopen(argv[1],"r");
		 grammarFile = fopen("grammar.txt","r");
		 initializeLexer();
		 initializeParser(grammarFile);
		 buildTreeAndParse(sourceFile);

     if(syntacticCorrectnessFlag == 0)
     {
       printf("Program is syntactically incorrect.\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }
     else{
       printErrorFlag = 0;
       createAST(root);
       initializeSymbolTableVariables();
       populateSymbolTable(root);
       calculateOffset();
       printMemory();
     }

	 }
	 else if(option==8)
	 {
		 sourceFile = fopen(argv[1],"r");
		 grammarFile = fopen("grammar.txt","r");
		 initializeLexer();
		 initializeParser(grammarFile);
		 buildTreeAndParse(sourceFile);

     if(syntacticCorrectnessFlag == 0)
     {
       printf("Program is syntactically incorrect.\n");
       fclose(sourceFile);
       fclose(grammarFile);
     }
     else{
        printErrorFlag = 0;
        createAST(root);
        initializeSymbolTableVariables();
        populateSymbolTable(root);
        calculateOffset();
        printGlobalRecords();
     }

	}

	else if(option==9)
	{
    sourceFile = fopen(argv[1],"r");
    grammarFile = fopen("grammar.txt","r");

    clock_t    start_time, end_time;
    double total_CPU_time, total_CPU_time_in_seconds;
    start_time = clock();


    initializeLexer();
    initializeParser(grammarFile);
    buildTreeAndParse(sourceFile);

    if(syntacticCorrectnessFlag == 0)
    {
      printf("Program is syntactically incorrect.\n");
      fclose(sourceFile);
      fclose(grammarFile);
    }
    else{
      printErrorFlag = 1;
      semanticCorrectnessFlag = 1;
      createAST(root);
      initializeSymbolTableVariables();
      populateSymbolTable(root);
      calculateOffset();
      semanticAnalyzer(root);
      end_time = clock();
      total_CPU_time  =  (double) (end_time - start_time);
      total_CPU_time_in_seconds =   total_CPU_time / CLOCKS_PER_SEC;

      if(semanticCorrectnessFlag == 0)
      {
        printf("Program is semantically incorrect. Errors printed above\n");
      }
      else
        printf("Program is syntactically and semantically correct. Code compiles successfully.\n");

      printf("\n\nTime in seconds:  %f\n", total_CPU_time_in_seconds);
      printf("Ticks: %d\n",CLOCKS_PER_SEC);
    }

	}
	else if(option==10)
	{
    sourceFile = fopen(argv[1],"r");
    grammarFile = fopen("grammar.txt","r");

    initializeLexer();
    initializeParser(grammarFile);
    buildTreeAndParse(sourceFile);

    if(syntacticCorrectnessFlag == 0)
    {
      printf("Program is syntactically incorrect. Can't create AST for the source code\n");
      fclose(sourceFile);
      fclose(grammarFile);
    }
    else{
      printErrorFlag = 1;
      createAST(root);
      semanticCorrectnessFlag = 1;
      initializeSymbolTableVariables();
      populateSymbolTable(root);
      calculateOffset();
      semanticAnalyzer(root);
      FILE* asmFile = fopen(argv[2],"w");
      if(semanticCorrectnessFlag == 1)
      {
          printf("Generating asm code.\n");
          reserveMemory(asmFile);
          generateStmtCode(root,asmFile);
          fclose(asmFile);
      }
      else{
        printf("Program is semantically incorrect. Errors printed above\n");
        fclose(asmFile);
      }
    }

	}
	 printf("\n\nEnter another option:\n");
	 scanf("%d",&option);


 }



 printf("\n\n");

 //printf("Printing the inorder traversal of the parse tree\n");
 //printInorderTraversal(root);

 return 0;
}
